import { Field } from './wrapped.js';
import { Provable } from './provable.js';
import { Struct } from './types/struct.js';
import { assert } from './gadgets/common.js';
import { provableFromClass } from './types/provable-derivers.js';
import { Poseidon, packToFields } from './crypto/poseidon.js';
import { Unconstrained } from './types/unconstrained.js';
export { MerkleListBase, MerkleList, MerkleListIterator, WithHash, emptyHash, genericHash, merkleListHash, withHashes, };
// common base types for both MerkleList and MerkleListIterator
const emptyHash = Field(0);
function WithHash(type) {
    return Struct({ previousHash: Field, element: type });
}
function toConstant(type, node) {
    return {
        previousHash: node.previousHash.toConstant(),
        element: Provable.toConstant(type, node.element),
    };
}
function MerkleListBase() {
    return class extends Struct({ hash: Field, data: Unconstrained.provable }) {
        static empty() {
            return { hash: emptyHash, data: Unconstrained.from([]) };
        }
    };
}
// merkle list
/**
 * Dynamic-length list which is represented as a single hash
 *
 * Supported operations are {@link push()} and {@link pop()} and some variants thereof.
 *
 *
 * A Merkle list is generic over its element types, so before using it you must create a subclass for your element type:
 *
 * ```ts
 * class MyList extends MerkleList.create(MyType) {}
 *
 * // now use it
 * let list = MyList.empty();
 *
 * list.push(new MyType(...));
 *
 * let element = list.pop();
 * ```
 *
 * Internal detail: `push()` adds elements to the _start_ of the internal array and `pop()` removes them from the start.
 * This is so that the hash which represents the list is consistent with {@link MerkleListIterator},
 * and so a `MerkleList` can be used as input to `MerkleListIterator.startIterating(list)`
 * (which will then iterate starting from the last pushed element).
 */
class MerkleList {
    constructor({ hash, data }) {
        this.hash = hash;
        this.data = data;
    }
    isEmpty() {
        return this.hash.equals(this.Constructor.emptyHash);
    }
    /**
     * Push a new element to the list.
     */
    push(element) {
        let previousHash = this.hash;
        this.hash = this.nextHash(previousHash, element);
        this.data.updateAsProver((data) => [
            toConstant(this.innerProvable, { previousHash, element }),
            ...data,
        ]);
    }
    /**
     * Push a new element to the list, if the `condition` is true.
     */
    pushIf(condition, element) {
        let previousHash = this.hash;
        this.hash = Provable.if(condition, this.nextHash(previousHash, element), previousHash);
        this.data.updateAsProver((data) => condition.toBoolean()
            ? [toConstant(this.innerProvable, { previousHash, element }), ...data]
            : data);
    }
    popWitness() {
        return Provable.witness(WithHash(this.innerProvable), () => {
            let [value, ...data] = this.data.get();
            let head = value ?? {
                previousHash: this.Constructor.emptyHash,
                element: this.innerProvable.empty(),
            };
            this.data.set(data);
            return head;
        });
    }
    /**
     * Remove the last element from the list and return it.
     *
     * This proves that the list is non-empty, and fails otherwise.
     */
    popExn() {
        let { previousHash, element } = this.popWitness();
        let currentHash = this.nextHash(previousHash, element);
        this.hash.assertEquals(currentHash);
        this.hash = previousHash;
        return element;
    }
    /**
     * Remove the last element from the list and return it.
     *
     * If the list is empty, returns a dummy element.
     */
    pop() {
        let { previousHash, element } = this.popWitness();
        let isEmpty = this.isEmpty();
        let emptyHash = this.Constructor.emptyHash;
        let currentHash = this.nextHash(previousHash, element);
        currentHash = Provable.if(isEmpty, emptyHash, currentHash);
        this.hash.assertEquals(currentHash);
        this.hash = Provable.if(isEmpty, emptyHash, previousHash);
        let provable = this.innerProvable;
        return Provable.if(isEmpty, provable, provable.empty(), element);
    }
    /**
     * Return the last element, but only remove it if `condition` is true.
     *
     * If the list is empty, returns a dummy element.
     */
    popIf(condition) {
        let originalHash = this.hash;
        let element = this.pop();
        // if the condition is false, we restore the original state
        this.data.updateAsProver((data) => {
            let node = { previousHash: this.hash, element };
            return condition.toBoolean()
                ? data
                : [toConstant(this.innerProvable, node), ...data];
        });
        this.hash = Provable.if(condition, this.hash, originalHash);
        return element;
    }
    clone() {
        let data = Unconstrained.witness(() => [...this.data.get()]);
        return new this.Constructor({ hash: this.hash, data });
    }
    startIterating() {
        let merkleArray = MerkleListIterator.createFromList(this.Constructor);
        return merkleArray.startIterating(this);
    }
    /**
     * Create a Merkle list type
     *
     * Optionally, you can tell `create()` how to do the hash that pushes a new list element, by passing a `nextHash` function.
     *
     * @example
     * ```ts
     * class MyList extends MerkleList.create(Field, (hash, x) =>
     *   Poseidon.hashWithPrefix('custom', [hash, x])
     * ) {}
     * ```
     */
    static create(type, nextHash = merkleListHash(type), emptyHash_ = emptyHash) {
        class MerkleListTBase extends MerkleList {
            static empty() {
                return new this({ hash: emptyHash_, data: Unconstrained.from([]) });
            }
            static from(array) {
                let { hash, data } = withHashes(array, nextHash, emptyHash_);
                let unconstrained = Unconstrained.witness(() => data.map((x) => toConstant(type, x)));
                return new this({ data: unconstrained, hash });
            }
            static get provable() {
                assert(this._provable !== undefined, 'MerkleList not initialized');
                return this._provable;
            }
        }
        MerkleListTBase._innerProvable = type;
        MerkleListTBase._provable = provableFromClass(MerkleListTBase, {
            hash: Field,
            data: Unconstrained.provable,
        });
        MerkleListTBase._nextHash = nextHash;
        MerkleListTBase._emptyHash = emptyHash_;
        // override `instanceof` for subclasses
        return class MerkleListT extends MerkleListTBase {
            static [Symbol.hasInstance](x) {
                return x instanceof MerkleListTBase;
            }
        };
    }
    get Constructor() {
        return this.constructor;
    }
    nextHash(hash, value) {
        assert(this.Constructor._nextHash !== undefined, 'MerkleList not initialized');
        return this.Constructor._nextHash(hash, value);
    }
    static get emptyHash() {
        assert(this._emptyHash !== undefined, 'MerkleList not initialized');
        return this._emptyHash;
    }
    get innerProvable() {
        assert(this.Constructor._innerProvable !== undefined, 'MerkleList not initialized');
        return this.Constructor._innerProvable;
    }
}
/**
 * MerkleListIterator helps iterating through a Merkle list.
 * This works similar to calling `list.pop()` repeatedly, but maintaining the entire list instead of removing elements.
 *
 * The core method that supports iteration is {@link next()}.
 *
 * ```ts
 * let iterator = MerkleListIterator.startIterating(list);
 *
 * let firstElement = iterator.next();
 * ```
 *
 * We maintain two commitments, both of which are equivalent to a Merkle list hash starting _from the end_ of the array:
 * - One to the entire array, to prove that we start iterating at the beginning.
 * - One to the array from the current index until the end, to efficiently step forward.
 */
class MerkleListIterator {
    constructor(value) {
        Object.assign(this, value);
    }
    assertAtStart() {
        return this.currentHash.assertEquals(this.hash);
    }
    isAtEnd() {
        return this.currentHash.equals(this.Constructor.emptyHash);
    }
    jumpToEnd() {
        this.currentIndex.setTo(Unconstrained.witness(() => this.data.get().length));
        this.currentHash = this.Constructor.emptyHash;
    }
    jumpToEndIf(condition) {
        Provable.asProver(() => {
            if (condition.toBoolean()) {
                this.currentIndex.set(this.data.get().length);
            }
        });
        this.currentHash = Provable.if(condition, this.Constructor.emptyHash, this.currentHash);
    }
    next() {
        // next corresponds to `pop()` in MerkleList
        // it returns a dummy element if we're at the end of the array
        let { previousHash, element } = Provable.witness(WithHash(this.innerProvable), () => this.data.get()[this.currentIndex.get()] ?? {
            previousHash: this.Constructor.emptyHash,
            element: this.innerProvable.empty(),
        });
        let isDummy = this.isAtEnd();
        let emptyHash = this.Constructor.emptyHash;
        let correctHash = this.nextHash(previousHash, element);
        let requiredHash = Provable.if(isDummy, emptyHash, correctHash);
        this.currentHash.assertEquals(requiredHash);
        this.currentIndex.updateAsProver((i) => Math.min(i + 1, this.data.get().length));
        this.currentHash = Provable.if(isDummy, emptyHash, previousHash);
        return Provable.if(isDummy, this.innerProvable, this.innerProvable.empty(), element);
    }
    clone() {
        let data = Unconstrained.witness(() => [...this.data.get()]);
        let currentIndex = Unconstrained.witness(() => this.currentIndex.get());
        return new this.Constructor({
            data,
            hash: this.hash,
            currentHash: this.currentHash,
            currentIndex,
        });
    }
    /**
     * Create a Merkle array type
     */
    static create(type, nextHash = merkleListHash(type), emptyHash_ = emptyHash) {
        var _a;
        return _a = class Iterator extends MerkleListIterator {
                static from(array) {
                    let { hash, data } = withHashes(array, nextHash, emptyHash_);
                    let unconstrained = Unconstrained.witness(() => data.map((x) => toConstant(type, x)));
                    return this.startIterating({ data: unconstrained, hash });
                }
                static startIterating({ data, hash, }) {
                    return new this({
                        data,
                        hash,
                        currentHash: hash,
                        currentIndex: Unconstrained.from(0),
                    });
                }
                static empty() {
                    return this.from([]);
                }
                static get provable() {
                    assert(this._provable !== undefined, 'MerkleListIterator not initialized');
                    return this._provable;
                }
            },
            _a._innerProvable = type,
            _a._provable = provableFromClass(_a, {
                hash: Field,
                data: Unconstrained.provable,
                currentHash: Field,
                currentIndex: Unconstrained.provable,
            }),
            _a._nextHash = nextHash,
            _a._emptyHash = emptyHash_,
            _a;
    }
    static createFromList(merkleList) {
        return this.create(merkleList.prototype.innerProvable, merkleList._nextHash);
    }
    get Constructor() {
        return this.constructor;
    }
    nextHash(hash, value) {
        assert(this.Constructor._nextHash !== undefined, 'MerkleListIterator not initialized');
        return this.Constructor._nextHash(hash, value);
    }
    static get emptyHash() {
        assert(this._emptyHash !== undefined, 'MerkleList not initialized');
        return this._emptyHash;
    }
    get innerProvable() {
        assert(this.Constructor._innerProvable !== undefined, 'MerkleListIterator not initialized');
        return this.Constructor._innerProvable;
    }
}
// hash helpers
function genericHash(provable, prefix, value) {
    let input = provable.toInput(value);
    let packed = packToFields(input);
    return Poseidon.hashWithPrefix(prefix, packed);
}
function merkleListHash(provable, prefix = '') {
    return function nextHash(hash, value) {
        let input = provable.toInput(value);
        let packed = packToFields(input);
        return Poseidon.hashWithPrefix(prefix, [hash, ...packed]);
    };
}
function withHashes(data, nextHash, emptyHash) {
    let n = data.length;
    let arrayWithHashes = Array(n);
    let currentHash = emptyHash;
    for (let i = n - 1; i >= 0; i--) {
        arrayWithHashes[i] = { previousHash: currentHash, element: data[i] };
        currentHash = nextHash(currentHash, data[i]);
    }
    return { data: arrayWithHashes, hash: currentHash };
}
//# sourceMappingURL=merkle-list.js.map