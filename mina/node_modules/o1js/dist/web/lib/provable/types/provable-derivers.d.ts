import { Provable, ProvablePure } from './provable-intf.js';
import type { Field } from '../wrapped.js';
import { NonMethods, InferProvable as GenericInferProvable, InferJson, InferredProvable as GenericInferredProvable, IsPure as GenericIsPure, Constructor } from '../../../bindings/lib/provable-generic.js';
import { Tuple } from '../../util/types.js';
import { GenericHashInput } from '../../../bindings/lib/generic.js';
export { ProvableExtended, provable, provablePure, provableTuple, provableFromClass, };
export { NonMethods, HashInput, InferProvable, InferJson, InferredProvable, IsPure, };
type ProvableExtension<T, TJson = any> = {
    toInput: (x: T) => {
        fields?: Field[];
        packed?: [Field, number][];
    };
    toJSON: (x: T) => TJson;
    fromJSON: (x: TJson) => T;
    empty: () => T;
};
type ProvableExtended<T, TJson = any> = Provable<T> & ProvableExtension<T, TJson>;
type ProvablePureExtended<T, TJson = any> = ProvablePure<T> & ProvableExtension<T, TJson>;
type InferProvable<T> = GenericInferProvable<T, Field>;
type InferredProvable<T> = GenericInferredProvable<T, Field>;
type IsPure<T> = GenericIsPure<T, Field>;
type HashInput = GenericHashInput<Field>;
declare const HashInput: {
    readonly empty: {};
    append(input1: GenericHashInput<import("../field.js").Field>, input2: GenericHashInput<import("../field.js").Field>): GenericHashInput<import("../field.js").Field>;
};
declare const provable: import("../../../bindings/lib/provable-generic.js").ProvableConstructor<import("../field.js").Field>;
declare function provablePure<A>(typeObj: A): ProvablePureExtended<InferProvable<A>, InferJson<A>>;
declare function provableTuple<T extends Tuple<any>>(types: T): InferredProvable<T>;
declare function provableFromClass<A, T extends InferProvable<A>>(Class: Constructor<T> & {
    check?: (x: T) => void;
    empty?: () => T;
}, typeObj: A): IsPure<A> extends true ? ProvablePureExtended<T, InferJson<A>> : ProvableExtended<T, InferJson<A>>;
